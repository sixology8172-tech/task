# Visible Widgets Quadtree Viewer

A high-performance implementation of a responsive document viewer backend using a Region Quadtree. This system efficiently queries visible rectangular widgets on a large 2D canvas, supporting smooth scrolling with millisecond-level response times.

## üìú Attestation

I certify that this solution is my own work. While I have consulted references and AI tools to clarify specific concepts, the design logic, implementation, and code structure submitted herein are generated by me.

## üöÄ Overview

The solution addresses the problem of rendering a viewport within a massive 2D canvas (up to 500,000 widgets) by using a **Region Quadtree** for spatial indexing. 

Instead of linearly iterating through all widgets ($O(N)$), the scroll handler queries the Quadtree ($O(\log N + k)$), retrieving only the widgets that intersect with the current viewport.

### Key Features
-   **Straddler Management**: Widgets that cross quadrant boundaries are stored in the parent node rather than being duplicated in child nodes. This handles heavy overlap clusters efficiently without memory bloat.
-   **Viewport Clipping**: Automatically handles edge cases where the viewport extends beyond the canvas boundaries.
-   **Input Validation**: Automatically ignores invalid widgets (non-positive width/height).

## üõ†Ô∏è Complexity Analysis & Design Justification

### 1. Time Complexity

* **Build Time: $O(N \log N)$**
    * Inserting a single rectangle typically takes $O(\log N)$ time as it traverses down the tree depth.
    * With $N$ rectangles, the total build time is average $O(N \log N)$.
    * *Worst Case*: $O(N \times D)$ where $D$ is max depth, occurring if objects are heavily clustered in one tiny area, forcing max depth traversal.

* **Query Time: $O(\log N + k)$**
    * $k$ is the number of reported results (hits).
    * The query algorithm uses **pruning**: if a tree node's bounds do not intersect the viewport, the entire branch is skipped.
    * For a typical document viewer where the viewport is small relative to the canvas, this results in extremely fast lookups (low milliseconds).

### 2. Parameter Justification

The Quadtree is tuned with specific parameters to balance memory usage and CPU cycles:

* **Bucket Capacity (`16`)**: 
    * **Why**: This is the threshold to split a node. A capacity of 1 would create a very deep tree, wasting memory on empty nodes. A capacity of 1000 would degrade leaf-node performance to linear search. 
    * **Justification**: 16 is a "sweet spot" where the cost of linearly iterating over 16 items in memory (very fast due to CPU caching) is cheaper than the overhead of recursing into another tree level.

* **Max Depth (`10`)**: 
    * **Why**: This limits how deep the tree can grow.
    * **Justification**: On a canvas of size 5000x5000, a depth of 10 results in leaf nodes of approximately $5000 / 2^{10} \approx 5$ pixels wide. Subdividing further is unnecessary because widgets are rarely smaller than 5 pixels. This prevents stack overflow errors and strictly limits worst-case insertion time.

## üìÇ Project Structure

* `main.py`: Entry point containing the `DocumentViewer` controller and required test cases.
* `quadtree.py`: The high-level interface managing the root node and global bounds.
* `quadtree_node.py`: The core recursive logic for the spatial data structure.
* `rectangle.py`: Data model and geometric intersection logic.

## üì¶ How to Run

Requirements: Python 3.6+ (Standard Library only).

1.  **Run the implementation and tests:**
    ```bash
    python main.py
    ```

2.  **Expected Output:**
    The script will print the IDs of the visible rectangles for the provided examples:
    ```text
    Example 1 Output IDs: [1, 2]
    Example 2 Output IDs: [1]
    ```